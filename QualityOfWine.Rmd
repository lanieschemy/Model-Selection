---
title: "Quality of Wine"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

## Introduction
For this assignment, we examined the relationship between the variables “quality” and “fixed acidity”, “volatile acidity”, “citric acid”, “residual sugar”, “chlorides”, “free sulfur dioxide”, “total sulfur dioxide”, “density”, “pH”, “sulphates”, and “alcohol”. The variable we're trying to predict, is the quality of wine based on our 11 predictors.

### Downloading Wine Quality Data Set
```{r}
Wine_Quality<- read.csv("~/Downloads/WineQT.csv")
View(Wine_Quality)
```

## Question 1
### Histogram and Fitted Distribution
 In histograms 1 (fixed acidity), 2 (volatile acidity), 4 (residual sugar), 5 (chlorides), 6 (free sulfur dioxide), 7 (total sulfur dioxide), 10 (sulphates), and 11 (alcohol) the models are right-skewed, meaning there is a positive distribution. Histograms 8 (pH) and 9 (density) have a normal distribution. By fitting a distribution to the histogram, we can predict as well as understand the observations in a data set better. The red line, inputted as curve(), shows the distribution that best fits the data.
```{r}
##Histogram
## Uses hist() to draw histogram
## Used curve() to draw normal distributed curve on histogram
library(fitdistrplus)
hist(Wine_Quality$fixed.acidity, prob = TRUE, xlab = "Fixed Acidity", ylab = "Frequency", main = "Frequency of Fixed Acidity")
hist(Wine_Quality$volatile.acidity, prob = TRUE, xlab = "Volatile Acidity", ylab = "Frequency", main = "Frequency of Volatile Acidity")
hist(Wine_Quality$citric.acid, xlab = "Citric Acid", ylab = "Frequency", main = "Frequency of Citric Acid")
hist(Wine_Quality$residual.sugar, xlab = "Residual Sugar", ylab = "Frequency", main = "Frequency of Residual Sugar")
hist(Wine_Quality$chlorides, xlab = "Chlorides", ylab = "Frequency", main = "Frequency of Chlorides")
hist(Wine_Quality$free.sulfur.dioxide, xlab = "Free Sulfur Dioxide", ylab = "Frequency", main = "Frequency of Free Sulfur Dioxide")
hist(Wine_Quality$total.sulfur.dioxide, xlab = "Total Sulfur Dioxide", ylab = "Frequency", main = "Frequency of Total Sulfur Dioxide")
hist(Wine_Quality$density, xlab = "Density", ylab = "Frequency", main = "Frequency of Density")
hist(Wine_Quality$pH, xlab = "pH", ylab = "Frequency", main = "Frequency of pH")
hist(Wine_Quality$sulphates, xlab = "Sulphates", ylab = "Frequency", main = "Frequency of Sulphates")
hist(Wine_Quality$alcohol, xlab = "Alcohol", ylab = "Frequency", main = "Frequency of Alcohol")
hist(Wine_Quality$quality, xlab = "Quality", ylab = "Frequency", main = "Frequency of Quality")

# Fitted Distribution
# Uses the fitdistr() to create fitted distribution
# uses the curve() for the fitted distribution 
fit1 <- fitdistr(Wine_Quality$fixed.acidity, densfun="normal")
curve(dnorm(x, fit1$estimate[1], fit1$estimate[2]), col="red", add=T)
fit2 <- fitdistr(Wine_Quality$volatile.acidity, densfun="normal")
curve(dnorm(x, fit2$estimate[1], fit2$estimate[2]), col="red", add=T)
fit3 <- fitdistr(Wine_Quality$citric.acid, densfun="normal")
curve(dnorm(x, fit3$estimate[1], fit3$estimate[2]), col="red", add=T)
fit4 <- fitdistr(Wine_Quality$residual.sugar, densfun="normal")
curve(dnorm(x, fit4$estimate[1], fit4$estimate[2]), col="red", add=T)
fit5 <- fitdistr(Wine_Quality$chlorides, densfun="normal")
curve(dnorm(x, fit5$estimate[1], fit5$estimate[2]), col="red", add=T)
fit6 <- fitdistr(Wine_Quality$free.sulfur.dioxide, densfun="normal")
curve(dnorm(x, fit6$estimate[1], fit6$estimate[2]), col="red", add=T)
fit7 <- fitdistr(Wine_Quality$total.sulfur.dioxide, densfun="normal")
curve(dnorm(x, fit7$estimate[1], fit7$estimate[2]), col="red", add=T)
fit8 <- fitdistr(Wine_Quality$density, densfun="normal")
curve(dnorm(x, fit8$estimate[1], fit8$estimate[2]), col="red", add=T)
fit9 <- fitdistr(Wine_Quality$pH, densfun="normal")
curve(dnorm(x, fit9$estimate[1], fit9$estimate[2]), col="red", add=T)
fit10 <- fitdistr(Wine_Quality$sulphates, densfun="normal")
curve(dnorm(x, fit10$estimate[1], fit10$estimate[2]), col="red", add=T)
fit11 <- fitdistr(Wine_Quality$alcohol, densfun="normal")
curve(dnorm(x, fit11$estimate[1], fit11$estimate[2]), col="red", add=T)
fit12 <- fitdistr(Wine_Quality$quality, densfun="normal")
curve(dnorm(x, fit12$estimate[1], fit12$estimate[2]), col="red", add=T)
```

### Correlation Plot
Based on the correlation plot above, there is a positive correlation between the quality of wine and alcohol, sulphates, citric acid, and fixed acidity. However, there is a negative correlation between wine quality and volatile acidity, chlorides, free sulfur dioxide, total sulfur dioxide, density, and pH.

```{r}
# Correlation Plot
# uses cor() to make correlation matrix 
# uses corrplot() to make correlation plot
library(corrplot)
M = cor(Wine_Quality)
corrplot(M, method = 'shade')
```

### Box Plot
Similar to a histogram, a box plot provides insight into the distribution of a data set. The box is the interquartile range of data, showing the values between the first and third quartile. The length of the box shows how spread out or concentrated the data is. It is evident by the models above that the data is moderately concentrated with the predictor variable citric acid having the largest spread and chlorides having the smallest spread. The points outside the box are outliers. Besides the predictor variables citric acid and alcohol, the rest have many outliers which will be helpful in determining what variables are best are predicting or explaining the response variable, quality.
```{r}
# Box Plot
# Uses boxplot() to create a boxplot
boxplot(Wine_Quality$fixed.acidity, main = "Fixed Acidity")
boxplot(Wine_Quality$volatile.acidity, main = "Volatile Acidity")
boxplot(Wine_Quality$citric.acid, main = "Citric Acid")
boxplot(Wine_Quality$residual.sugar, main = "Residual Sugar")
boxplot(Wine_Quality$chlorides, main = "Chlorides")
boxplot(Wine_Quality$free.sulfur.dioxide, main = "Free Sulfur Dioxide")
boxplot(Wine_Quality$total.sulfur.dioxide, main = "Total Sulfur Dioxide")
boxplot(Wine_Quality$density, main = "Density")
boxplot(Wine_Quality$pH, main = "PH")
boxplot(Wine_Quality$sulphates, main = "Sulphates")
boxplot(Wine_Quality$alcohol, main = "Alcohol")
```

### Scatter Plot
A scatterplot shows the relationship between two variables. In this data set, it's a visual of the relationship between the quality of wine and fixed acidity, pH, alcohol, etc... Variables with a strong relationship will have clusters of data points while variables with weak relationships will have data points that are spread out. From the scatter plots above, we can conclude that there is a strong relationship between wine quality and the other variables as of now.

```{r}
# Scatter Plot
# uses plot() to create the graph with type = "p" for scatter plot
plot(Wine_Quality$fixed.acidity, Wine_Quality$quality, xlab="Fixed Acidity", ylab="Quality", main = "Scatterplot of Fixed Acidity and Quality",type = "p")
plot(Wine_Quality$volatile.acidity, Wine_Quality$quality, xlab="Volatile Acidity", ylab="Quality", main = "Scatterplot of Volatile Acidity and Quality",type = "p")
plot(Wine_Quality$citric.acid, Wine_Quality$quality, xlab="Citric Acid", ylab="Quality", main = "Scatterplot of Citric Acid and Quality",type = "p")
plot(Wine_Quality$residual.sugar, Wine_Quality$quality, xlab="Residual Sugar", ylab="Quality", main = "Scatterplot of Residual Sugar and Quality",type = "p")
plot(Wine_Quality$chlorides, Wine_Quality$quality, xlab="Chlorides", ylab="Quality", main = "Scatterplot of Chlorides and Quality",type = "p")
plot(Wine_Quality$free.sulfur.dioxide, Wine_Quality$quality, xlab="Free Sulfur Dioxide", ylab="Quality", main = "Scatterplot of Free Sulfur Dioxide and Quality",type = "p")
plot(Wine_Quality$total.sulfur.dioxide, Wine_Quality$quality, xlab="Total Sulfur Dioxide", ylab="Quality", main = "Scatterplot of Total Sulfur Dioxide and Quality",type = "p")
plot(Wine_Quality$density, Wine_Quality$quality, xlab="Density", ylab="Quality", main = "Scatterplot of Density and Quality",type = "p")
plot(Wine_Quality$pH, Wine_Quality$quality, xlab="PH", ylab="Quality", main = "Scatterplot of PH and Quality",type = "p")
plot(Wine_Quality$sulphates, Wine_Quality$quality, xlab="Sulphates", ylab="Quality", main = "Scatterplot of Sulphates and Quality",type = "p")
plot(Wine_Quality$alcohol, Wine_Quality$quality, xlab="Alcohol", ylab="Quality", main = "Scatterplot of Alcohol and Quality",type = "p")
```


### Statistical Summary
Summarizing the data set provides us information about the minimum, 1st quartile, mean, 3rd quartile, and maximum of each variable. Having the average value of each variable, the mean, helps us compare variables and identify outliers. 
```{r}
# Statistical Summary (Five-Number Summary)
# Uses summary() for statistical summary
summary(Wine_Quality)
```

## Question 2
### Multiple Linear Regression Model

```{r}
# Estimating The Multiple Linear Regression Model
# uses lm() to create linear model
# uses summary() to display regression details
wineq <- lm(quality ~ fixed.acidity + volatile.acidity + citric.acid + residual.sugar + chlorides + free.sulfur.dioxide + total.sulfur.dioxide + density + pH + sulphates + alcohol, data = Wine_Quality)
summary(wineq)
```

## Question 3
### Outlier, High Leverage, and New Model
It is evident that there are outliers and high leverage observations by the values outputted by the boxplot.stats() and hats() codes. The values derived by performing these tests corroborate the outcomes of the histogram, boxplot, scatterplot, and summary functions. These values are important because they are capable of altering the model’s best-fit line.
```{r}
# Outlier
# uses boxplot.stats() with $out  to capture outliers 
boxplot.stats(Wine_Quality$fixed.acidity)$out
boxplot.stats(Wine_Quality$volatile.acidity)$out
boxplot.stats(Wine_Quality$citric.acid)$out
boxplot.stats(Wine_Quality$residual.sugar)$out
boxplot.stats(Wine_Quality$chlorides)$out
boxplot.stats(Wine_Quality$free.sulfur.dioxide)$out
boxplot.stats(Wine_Quality$total.sulfur.dioxide)$out
boxplot.stats(Wine_Quality$density)$out
boxplot.stats(Wine_Quality$pH)$out
boxplot.stats(Wine_Quality$sulphates)$out
boxplot.stats(Wine_Quality$alcohol)$out
# High Leverage
# creates a dataframe named hats 
# uses hatvalues to be able to see high leverage
hats <- as.data.frame(hatvalues(wineq))
hats
hats[order(hats['hatvalues(wineq)']), ]
plot(hatvalues(wineq), type = 'h')
# New Regression Model
wineq2 <- lm(quality ~ volatile.acidity + chlorides + free.sulfur.dioxide + total.sulfur.dioxide + pH + sulphates + alcohol, data = Wine_Quality)
summary(wineq2)
```

## Question 4
### Boruta Algorithm
We first used the Boruta Algorithm to filter out which response variables were insignificant before also conducting the Mallows CP test. With the Boruta Algorithm we were able to see that alcohol was the best variable, as it had the highest importance. Also, we could eliminate variables that reported “rejected” from this test which meant they had no significance. Next, we took only the results of the significant variables from the Boruta algorithm and ran the Mallows CP test. Here, the smaller the value, the better the model. Evidently, the best model had the predictors volatile acidity, chlorides, total sulfur dioxide, sulphates, and alcohol. The models to the right of the model are higher and therefore, insignificant. These two tests helped us create a better model by determining and eliminating what variables were insignificant.
```{r}
library(Boruta)
# Uses Boruta() for Boruta algorithm process
Bor.res <- Boruta(quality ~ volatile.acidity + chlorides + free.sulfur.dioxide + total.sulfur.dioxide + pH + sulphates + alcohol, data = Wine_Quality, doTrace = 2)
plot(Bor.res, xlab = "", xaxt = "n", main="Boruta Algorithm")
Lz <- lapply(1:ncol(Bor.res$ImpHistory),function(i) Bor.res$ImpHistory[is.finite(Bor.res$ImpHistory[,i]),i])
names (Lz) <- colnames(Bor.res$ImpHistory)
Labels <- sort(sapply(Lz,median))
axis(side = 1,las=2,labels = names(Labels),
at = 1:ncol(Bor.res$ImpHistory), cex.axis = 0.7)
boruta_signif <- names(Bor.res$finalDecision[Bor.res$finalDecision %in% c("Confirmed", "Tentative")])
boruta_signif_Conf <- names(Bor.res$finalDecision[Bor.res$finalDecision %in% c("Confirmed")])
boruta_signif_Tent <- names(Bor.res$finalDecision[Bor.res$finalDecision %in% c("Tentative")])
boruta_signif_Reject <- names(Bor.res$finalDecision[Bor.res$finalDecision %in% c("Rejected")])
print(boruta_signif_Conf)
attStats(Bor.res)
sorted_vars = attStats(Bor.res)[order(-attStats(Bor.res)$meanImp),]
print(sorted_vars)

# Mallows CP
library(AER)
library(leaps)
# Codes use subsets and regsubset to perform the Mallows CP
mcp <- lm(quality ~ volatile.acidity + citric.acid + chlorides + total.sulfur.dioxide + density + sulphates + alcohol, data = Wine_Quality)
ss =regsubsets(quality ~ volatile.acidity + citric.acid  + chlorides  + total.sulfur.dioxide + density  + sulphates + alcohol, method = c("exhaustive"), nbest = 3, data = Wine_Quality) 
subsets(ss, statistic = "cp", legend =F , main = "Mallows CP", col = "green", min.size = 4)
```

## Question 5 
### Multi Collinearity with VIF
With the output for the vif(), all of the predictor variables are in the range of [1,2]. This means there are no variables that are highly correlated with another. Therefore the model with the removed variables won’t have significant issues with multicollinearity. 

```{r}
# Multi Collinearity
vifFunction<- lm(quality ~ volatile.acidity  + chlorides +  total.sulfur.dioxide + sulphates + alcohol,data = Wine_Quality)
vif(vifFunction)

```

## Question 6
### Plotting The Respective Residuals
The graph with residuals versus fitted shows a red line that tries to capture all of the residuals. There are more values that are above the red line than below the red line. The residuals vs y-hat plot lets us visualize whether heteroskedasticity is present. Our results show that there is a spread in the variance, which allows us to conclude that heteroskedasticity is present in our model. 
```{r}
# Plotting Respective Residuals/VIF Function
plot(vifFunction)

# Just to see more of the actual residuals
plot(residuals(vifFunction))
```

## Question 7
### Heteroskedasticity
Using the Breusch Pagan test, we reject the null and conclude there is heteroskedasticity present. To fix this, weapply robust standard errors. With this, all of our variables are significant and the standard errors decreased resultingi n a better model.
```{r}
reg.mod = lm(quality ~ volatile.acidity  + chlorides +  total.sulfur.dioxide + sulphates + alcohol, data = Wine_Quality) 
# BP Test Short Way
bptest(reg.mod)
# BP Test Long Way
alpha <- 0.05
ressq <- resid(reg.mod)^2
modres <- lm(ressq~volatile.acidity  + chlorides +  total.sulfur.dioxide + sulphates + alcohol, data = Wine_Quality)
summary(modres)

#Robust Standard Errors
cov1<-hccm(reg.mod, type="hc1")
coeftest(reg.mod, vcov.=cov1)
```

## Question 8
### AIC/BIC Model
Visualizing the plot of the respective residuals and y-hats in question 6, it seemed that the best fit could be a log linear form. With AIC/BIC we are able to see if our hypothesis is correct. We included different models with varying predictors, the best model we have found previously, and in the best model in terms of log. From the results, the best model is still the best model but better as a log linear with the same predictors obtained from previous tests.
```{r}
#AIC Model
# For the new model, it is in log linear form. 
bestMOD<- lm(log(quality) ~ chlorides + total.sulfur.dioxide + sulphates + alcohol + volatile.acidity, data=Wine_Quality)
bestMOD2<- lm(quality ~ chlorides + total.sulfur.dioxide + sulphates + alcohol + volatile.acidity, data=Wine_Quality)
MOD_1 <- lm(log(quality) ~ sulphates + alcohol,data = Wine_Quality)
MOD_2 <- lm(log(quality) ~ pH + sulphates + alcohol,data = Wine_Quality)
MOD_3 <-  lm(log(quality) ~ density + pH + sulphates + alcohol,data = Wine_Quality)
MOD_4 <- lm(log(quality) ~  total.sulfur.dioxide + density + pH + sulphates + alcohol,data = Wine_Quality)
MOD_5 <- lm(log(quality) ~ free.sulfur.dioxide + total.sulfur.dioxide + density + pH + sulphates + alcohol,data = Wine_Quality)
MOD_6 <- lm(log(quality) ~ chlorides + free.sulfur.dioxide + total.sulfur.dioxide + density + pH + sulphates + alcohol,data = Wine_Quality)
MOD_7 <-lm(log(quality) ~ residual.sugar + chlorides + free.sulfur.dioxide + total.sulfur.dioxide + density + pH + sulphates + alcohol,data = Wine_Quality)
MOD_8 <-lm(log(quality) ~ citric.acid + residual.sugar + chlorides + free.sulfur.dioxide + total.sulfur.dioxide + density + pH + sulphates + alcohol,data = Wine_Quality)
MOD_9 <- lm(log(quality) ~ volatile.acidity + citric.acid + residual.sugar + chlorides + free.sulfur.dioxide + total.sulfur.dioxide + density + pH + sulphates + alcohol,data = Wine_Quality)
MOD_10<- lm(log(quality) ~ fixed.acidity + volatile.acidity + citric.acid + residual.sugar + chlorides + free.sulfur.dioxide + total.sulfur.dioxide + density + pH + sulphates + alcohol,data = Wine_Quality)
AIC(MOD_1, MOD_2, MOD_3, MOD_4, MOD_5, MOD_6, MOD_7, MOD_8, MOD_9, MOD_10, bestMOD, bestMOD2)
BIC(MOD_1, MOD_2, MOD_3, MOD_4, MOD_5, MOD_6, MOD_7, MOD_8, MOD_9, MOD_10, bestMOD, bestMOD2)
```

## Question 9
### Cross-Validation
We performed a 5-fold cross validation and obstained an RMSE of .11608. This means that on average the predicted value is off by .11608. We also split the data into testing/training and calculated the RMSE for both and got small numbers. Overall, we can conclude our model is a good fit for our data and the results are accurate. 
```{r}
# train for training sample
# test for testing sample
set.seed(1)
row.number <- sample(1:nrow(Wine_Quality), 0.66*nrow(Wine_Quality))
train = Wine_Quality[row.number,]
test = Wine_Quality[-row.number,]
reg.mod=lm(log(quality) ~ volatile.acidity  + chlorides +  total.sulfur.dioxide + sulphates + alcohol, data=train)
#RMSE
sqrt(mean(log(test$quality)-predict(reg.mod,test))^2)
sqrt(mean(log(train$quality)-predict(reg.mod,train))^2)
# Cross Validation
library(lmvar)
fit= lm(log(quality) ~ volatile.acidity  + chlorides +  total.sulfur.dioxide + sulphates + alcohol,x = TRUE, y = TRUE, data=Wine_Quality)
cv.lm(fit, k = 5)
```


## Question 10
### Summary 
We first observed our data through boxplots and histograms which allowed us to determine and eliminate outliers from our model to increase our R^2. To continue to find the best model, we used the Boruta algorithm to identify the most significant variable, alcohol. This test also allowed us to eliminate insignificant variables. With this, we strengthened our model by performing another test, the Mallows CP Test which revealed that the model containing volatile acidity, chlorides, total sulfur dioxide, sulphates, and alcohol was the best. Additionally, another tool to create the best model is identifying whether or not heteroskedasticity is present. By using the BP test and visually looking at the residuals and y-hats plot, we determined that heteroskedasticity was present. To have the best model, we had to reduce the spread in errors. As a way to correct this, we performed the White Test, improving our standard errors. The residuals and y hat plot also showed us that the log-linear model would better predict our estimates. This was also confirmed when performing the cross validation test which in the end, showed how well we predicted our model. From these results, the root mean squared error value was low which means we estimated our model well. 
